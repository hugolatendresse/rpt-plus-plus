
Size of hugo's L3 cache: 24Mib (25.1 million bytes)
In general, we want half of the L3 cache to be hot.


******* PLAIN DUCKDB TEST *******

Each hash table entry is 8 bytes.

That means the hot portion is 25,100,000 / 2 / 8 = 1,500,000 entries

We want the probe to be very long, and hit each entry multiple times!!! 
That should be a tunable parameter, but suppose we hit each entry 100 times. 

That's 150,000,000 rows in the fact table (LHS/probe side). That's a 28-bit identifier.


Then, we can make the cold portion of the hash table much bigger. 

TODO right now I changed the hash function for everything... try to change only the hash function for hash join stuff I guess?
TODO salts could mess-up by forcing of the hashing scheme!!! Should I disable them? Or do salts only mean a fingerprint?

TODOfigure out how to run on 4 threads

TODO: more apples to apples comparison might be to always have a big build-side table, BUT have the cold and hot portions to be contiguous, this way we effectively do not bring the cold portion in memory. 
Because otherwise, it's hard to do an apples-to-apples comparison where we have the build side creation be faster or slower.

TODO need to understand how chains work. How can each hash table entry be only 8 bytes if they can also contain the chain pointer?

TODO need to understand which path in TightLoopHash is taken for the hashing.

TODO decide what I do with MurmurHash64 - do we do regular hash, parity conserving hash, or 32-bit key conserving hash?

TODO NEED TO MAKE SURE THAT THE COLD ENTRIES HASH TO SOMETHING DIFFERENT THAN THE HOT ENTRIES!!!!!!!!!!!!!!!!!!!!!!
One approach to do that is to hack the hash function to have, for example, last digit be 0 when we want cold and last digit be 1 when we want hot.
That itself can be based on the last digit of the column. Odd keys will be hot, and even keys will never be used. 
Hence the LHS contains only odd keys.

TODO create an assertion that we have zero collisions initially (to make sure my hashing works).
TODO ... then write tests that actually have assertions?

In terms of how the space that's 

TODO As we probe, where does the new data go? Won't that take up L3 space as well? 
SOLUTION: we probably want to just use the hash table and do experiments on it at first?
What we can also do is profile the probing part. That's probably the most reasonable idea. We do have multiple threads, but they should be all synced.

TODO is the size of the hashtable the same for all threads?

TODO How big is one entry in the Duck DB hashtable?

TODO how can we control the number of threads used? 



















******* SIMPLY HASH TABLE IN C++ TEST *******

TODO